# Email Sandbox Architecture

## 🔌 端口说明

### 核心服务端口

| 端口 | 服务名称 | 作用 | 访问方式 |
|------|---------|------|---------|
| **1025** | Mailpit SMTP | 接收和存储所有邮件的 SMTP 服务器 | SMTP 协议 |
| **8025** | Mailpit Web API | Mailpit 原生 API，提供邮件查询和管理 | HTTP REST API |
| **8030** | Auth API | 用户认证服务，处理登录、注册、Token 管理 | HTTP REST API |
| **8031** | API Proxy | 邮件 API 代理，验证 Token 并过滤用户邮件 | HTTP REST API |
| **8840** | MCP Server | Model Context Protocol 服务器，供 AI Agent 调用 | HTTP + SSE |

### 前端服务端口

| 端口 | 服务名称 | 作用 | 访问方式 |
|------|---------|------|---------|
| **8025** | Gmail UI (Docker) | 生产环境的 Gmail 界面（Nginx） | HTTP (浏览器) |
| **3001** | Gmail UI (Dev) | 开发环境的 Gmail 界面（Vite） | HTTP (浏览器) |

### Langflow 端口

| 端口 | 服务名称 | 作用 | 访问方式 |
|------|---------|------|---------| 
| **7860** | Langflow | AI Agent 工作流平台 | HTTP (浏览器) |

## 🐳 Docker 部署

所有服务都已 Docker 化，可以通过 `docker-compose.yml` 一键启动：

```bash
docker compose up -d --build
```

### Docker 服务列表

| 容器名称 | 服务 | 端口映射 | 依赖 |
|---------|------|---------|------|
| `mailpit` | Mailpit SMTP/API | 1025:1025 | - |
| `email-user-service` | Auth API + API Proxy | 8030:8030, 8031:8031 | mailpit |
| `mailpit-gmail-ui` | Gmail UI (Nginx) | 8025:80 | mailpit, user-service |
| `email-mcp-server` | MCP Server | 8840:8840 | mailpit, user-service |

### 容器间通信

容器内部通过 Docker 网络互相访问：
- MCP Server → API Proxy: `http://user-service:8031`
- MCP Server → Auth API: `http://user-service:8030`
- MCP Server → Mailpit SMTP: `mailpit:1025`
- Gmail UI → API Proxy: `http://user-service:8031`
- Gmail UI → Auth API: `http://user-service:8030`

## 📊 完整的信息调用流程

### 流程 1: 用户通过 Gmail UI 发送邮件

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. 用户在 Gmail UI 点击 "Send"                                        │
│    URL: http://localhost:3001 (Dev) 或 http://localhost:8025 (Prod) │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. 前端发送 POST 请求到 API Proxy                                     │
│    POST http://localhost:8031/api/v1/send                           │
│    Headers: Authorization: Bearer <access_token>                    │
│    Body: { to, subject, body, cc, bcc }                            │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. API Proxy 验证 Access Token                                       │
│    - 解析 JWT Token                                                  │
│    - 验证 Token 有效性和过期时间                                       │
│    - 提取用户信息 (user_id, email)                                   │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 4. API Proxy 强制设置发件人为当前用户                                  │
│    from_email = current_user["email"]  # 防止伪造发件人               │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 5. API Proxy 通过 SMTP 发送邮件到 Mailpit                            │
│    SMTP Connection: localhost:1025                                  │
│    - 构建 MIME 邮件                                                  │
│    - 发送到 Mailpit SMTP 服务器                                      │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 6. Mailpit 接收并存储邮件                                             │
│    - 保存邮件到内存/磁盘                                              │
│    - 生成邮件 ID                                                     │
│    - 触发 Webhook (如果配置)                                         │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 7. API Proxy 记录邮件所有权                                           │
│    - 发件人拥有该邮件                                                 │
│    - 所有收件人（To/Cc/Bcc）拥有该邮件                                │
│    - 存储到 SQLite 数据库                                            │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 8. 返回成功响应给前端                                                 │
│    Response: { ok: true, from, to, subject }                        │
└─────────────────────────────────────────────────────────────────────┘
```

### 流程 2: 用户通过 Gmail UI 查看邮件列表

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. 用户打开 Gmail UI 收件箱                                           │
│    URL: http://localhost:3001                                       │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. 前端发送 GET 请求到 API Proxy                                      │
│    GET http://localhost:8031/api/v1/messages?limit=20              │
│    Headers: Authorization: Bearer <access_token>                    │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. API Proxy 验证 Access Token                                       │
│    - 提取用户信息 (user_id, email)                                   │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 4. API Proxy 请求 Mailpit API 获取所有邮件                            │
│    GET http://mailpit:8025/api/v1/messages?limit=20                │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 5. Mailpit 返回所有邮件列表                                           │
│    Response: { messages: [...], total: 100 }                        │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 6. API Proxy 过滤邮件（只保留用户拥有的邮件）                          │
│    - 查询数据库：哪些邮件属于当前用户                                  │
│    - 过滤掉用户不拥有的邮件                                           │
│    - 添加用户特定状态（已读/星标）                                     │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 7. 返回过滤后的邮件列表给前端                                         │
│    Response: { messages: [用户的邮件], total: 5 }                    │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 8. 前端渲染邮件列表                                                   │
│    - 显示发件人、主题、摘要、时间                                      │
│    - 显示未读/星标状态                                                │
└─────────────────────────────────────────────────────────────────────┘
```

### 流程 3: AI Agent 通过 MCP Server 操作邮件

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. Langflow 中的 AI Agent 需要查看邮件                                │
│    URL: http://localhost:7860                                       │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. Langflow 调用 Mailpit MCP Client 组件                             │
│    - 配置 MCP Server URL: http://localhost:8840                     │
│    - 配置 Access Token: tok_xxx (用户的 Token)                       │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. MCP Client 发送请求到 MCP Server                                  │
│    POST http://localhost:8840/message                               │
│    Body: {                                                          │
│      method: "tools/call",                                          │
│      params: {                                                      │
│        name: "list_messages",                                       │
│        arguments: {                                                 │
│          limit: 20,                                                 │
│          access_token: "tok_xxx"                                    │
│        }                                                            │
│      }                                                              │
│    }                                                                │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 4. MCP Server 解析请求并调用对应的工具函数                             │
│    - 识别工具: list_messages                                         │
│    - 提取参数: limit=20, access_token="tok_xxx"                     │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 5. MCP Server 请求 API Proxy                                         │
│    GET http://localhost:8031/api/v1/messages?limit=20              │
│    Headers: Authorization: Bearer tok_xxx                           │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 6. API Proxy 验证 Token 并过滤邮件                                    │
│    (与流程 2 的步骤 3-6 相同)                                         │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 7. MCP Server 格式化响应并返回给 Langflow                             │
│    Response: {                                                      │
│      content: [{                                                    │
│        type: "text",                                                │
│        text: "[{邮件1}, {邮件2}, ...]"                               │
│      }]                                                             │
│    }                                                                │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 8. Langflow 将结果传递给 AI Agent                                     │
│    - AI 分析邮件内容                                                  │
│    - 决定下一步操作（回复、转发等）                                    │
└─────────────────────────────────────────────────────────────────────┘
```

### 流程 4: 用户登录认证流程

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. 用户在 Gmail UI 输入邮箱和密码                                     │
│    Email: alice@example.com                                         │
│    Password: password123                                            │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. 前端发送登录请求到 Auth API                                        │
│    POST http://localhost:8030/api/v1/auth/login                    │
│    Body: { email, password }                                        │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. Auth API 验证用户凭据                                              │
│    - 查询数据库：用户是否存在                                         │
│    - 验证密码哈希                                                    │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 4. Auth API 生成 JWT Token                                           │
│    - Access Token (有效期: 30分钟)                                   │
│    - Refresh Token (有效期: 7天)                                     │
│    - Token 包含: user_id, email, exp                                │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 5. 返回 Token 给前端                                                  │
│    Response: {                                                      │
│      access_token: "tok_xxx",                                       │
│      refresh_token: "ref_xxx",                                      │
│      user: { id, email, username }                                  │
│    }                                                                │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 6. 前端保存 Token 到 LocalStorage                                     │
│    - localStorage.setItem('access_token', token)                    │
│    - 后续所有请求都携带此 Token                                       │
└─────────────────────────────────────────────────────────────────────┘
```

## 🔐 安全机制

### Token 验证流程

```
每个需要认证的请求:
1. 客户端在 Header 中携带: Authorization: Bearer <access_token>
2. API Proxy 或 Auth API 验证:
   - 解析 JWT Token
   - 验证签名
   - 检查过期时间
   - 提取用户信息
3. 如果 Token 无效或过期:
   - 返回 401 Unauthorized
   - 前端自动跳转到登录页
```

### 邮件隔离机制

```
每封邮件的访问控制:
1. 邮件发送时:
   - 记录发件人拥有此邮件
   - 记录所有收件人（To/Cc/Bcc）拥有此邮件
   
2. 邮件查询时:
   - 从 Mailpit 获取所有邮件
   - 查询数据库：当前用户拥有哪些邮件
   - 只返回用户拥有的邮件
   
3. 邮件操作时（读取、删除、回复）:
   - 验证用户是否拥有该邮件
   - 如果不拥有，返回 404 Not Found
```

## 📦 数据存储

### Mailpit (内存/磁盘)
- **存储内容**: 所有邮件的完整内容（主题、正文、附件等）
- **存储位置**: 内存或磁盘（根据配置）
- **访问方式**: HTTP API (端口 8025)

### SQLite 数据库 (user_service/data/users.db)
- **存储内容**:
  - 用户信息 (users 表): id, email, username, password_hash
  - 邮件所有权 (email_ownership 表): message_id, user_id
  - 用户状态 (user_message_status 表): message_id, user_id, read, starred
- **访问方式**: Python SQLite3 库

## 🔄 服务依赖关系

```
Gmail UI (3001/8025)
    │
    ├─→ Auth API (8030) ─→ SQLite DB
    │
    └─→ API Proxy (8031)
            │
            ├─→ Auth API (8030) [验证 Token]
            ├─→ Mailpit API (8025) [获取邮件]
            ├─→ Mailpit SMTP (1025) [发送邮件]
            └─→ SQLite DB [邮件所有权]

Langflow (7860)
    │
    └─→ MCP Server (8840)
            │
            └─→ API Proxy (8031)
                    │
                    └─→ (与上面相同)
```

## 🚀 启动顺序

推荐的服务启动顺序：

1. **Mailpit** (Docker) - 端口 1025, 8025
2. **User Service** (Docker) - 端口 8030, 8031
3. **MCP Server** (可选) - 端口 8840
4. **Gmail UI** (Docker 或 Dev) - 端口 8025 或 3001
5. **Langflow** (可选) - 端口 7860

```bash
# 一键启动所有 Docker 服务
cd dt-platform/email_sandbox
docker compose up -d

# 启动 MCP Server (如果需要 AI Agent)
cd mcp_server/gmail_mcp
npx -y supergateway --port 8840 --stdio ./run_mcp.sh

# 启动 Langflow (如果需要)
cd dt-platform
uv run langflow run --port 7860 --host 0.0.0.0
```

## 📝 总结

这个架构的核心设计理念是：

1. **分层隔离**: 前端 → API Proxy → Mailpit，每层都有明确的职责
2. **Token 认证**: 所有 API 调用都需要有效的 Access Token
3. **邮件隔离**: 用户只能访问自己的邮件，通过数据库记录所有权
4. **多接口支持**: 支持 Web UI、MCP Server、直接 API 调用
5. **安全优先**: 强制发件人验证，防止邮件伪造

这样的设计既保证了安全性，又提供了灵活的集成方式，适合 AI Agent 测试和开发。

